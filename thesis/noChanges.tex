\chapter{Indirekte Fernlokalisierung mit 802.11}
\label{ch:phase1}
In einem ersten Schritt sollten laut Aufgabenstellung keine Veränderungen an den Access Points vorgenommen werden können.
Weil die Ortung deshalb auf WLAN basieren muss sind die Basisstationen im Folgenden immer APs. 
%TODO Ein Tag ist eine mobile Einheit, umgekehrt gilt dies jedoch nicht, da auch alle anderen WLAN-fähigen Geräte, wie Smartphones und Laptops, eine mobile Einheit sein können. \\
Die Unveränderlichkeit bedeutet insbesondere auch, dass keine Messwerte verwendet werden können, die direkt am AP gemessen werden und nicht als Teil der 802.11 Spezifikation in das dahinterliegende Netzwerk weitergeleitet werden.
Da time of arrival Synchronisation und präzise Timer bei den APs vorraussetzt und time difference of arrival nur von den APs gemessen werden kann, eignen sich diese Messgrößen nicht für diese Aufgabenstellung.
Received signal strength und roundtrip time of flight können auf der mobilen Einheit gemessen werden, nicht jedoch an den APs, da die in der PHY- beziehungsweise MAC-Schicht gemessenen Werte nicht an weitere Empfänger im Netzwerk propagiert werden. 
Somit scheidet die direkte Fernlokalisierung mangels Messgrößen aus, es wird stattdessen eine indirekte Fernlokalisierung durchgeführt bei der die mobile Einheit eine Selbstlokalisierung durchführt und das Ergebnis dem Ortungsserver über eine Datenverbindung mitteilt.

\begin{figure}[h]
  \centering
	\includegraphics[width=\textwidth]{images/espblock.png}
  \caption{Blockdiagramm des ESP8266, aus \cite{espressif2017esp8266}}
  \label{fig:espblock}
\end{figure}







\section{ESP8266}
Der ESP8266 soll als Hardware für das Tag eingesetzt werden, dabei handelt es sich um einen Microcontroller von Espressif.
Der ESP8266 besitzt neben einer CPU eine 802.11b/g/n"-/e/i-fähige WLAN-Einheit und beherrscht diverse andere, kabelgebundene Kommunikationsstandards wie zum Beispiel GPIO, I2C und SPI, siehe Abbildung \ref{fig:espblock}. \\
Da der ESP8266 selbst weder über Flashspeicher, noch über eine Antenne verfügt wird er auf einem Modul mit diesen Komponenten verbaut. 
Die in dieser Arbeit betrachteten Module sind das ESP12-S und das ESP12-F.
Das neuere ESP12-F sollte eine höhere Reichweite bei der Funkübertragung entfalten, dies wird noch Gegenstand eines Experiments sein.
%TODO Antennen markieren
Abbildung \ref{fig:espmodules} zeigt die beiden Module nebeneinander, die unterschiedlichen Antennenformen sind deutlich zu erkennen.\\
Espressif gibt im Datenblatt auch Aufschluss über den Energieverbrauch des ESPs, siehe dazu Tabelle \ref{table:esppower}.
Für die Prototypenentwicklung wird ein ESP12-S Modul auf einem Adafruit Feather Huzzah verwendet, dieses stellt mit dem CP2104 eine serielle Verbindung zum ESP her, reguliert die Spannung für das Modul auf 3,3V und bringt den 2mm Pinabstand des ESP12-S Moduls auf die für Breadboards üblichen 2,5mm.
Das Adafruit Feather Huzzah mit ESP12-S ist in Abbildung \ref{fig:espmodules} links abgebildet.

\begin{figure}[h]
  \centering
	\includegraphics[width=\textwidth]{images/espmodules.png}
  \caption{Vergleich der Antennen, links: ESP12-S verbaut auf einem Adafruit Feather Huzzah, rechts: ESP12-F}
  \label{fig:espmodules}
\end{figure}

\begin{table}[h]
  \centering
  \caption{Energieverbrauch des ESP8266 bei verschiedenen Operationen, aus \cite{espressif2017esp8266}}
	\includegraphics[width=\textwidth]{images/esppower.png}

  \label{table:esppower}
\end{table}


\subsection{ESP8266 Arduino Core}
Eine einfache Möglichkeit den ESP8266 zu programmieren stellt die bekannte Arduino IDE dar \cite{banzi2017arduino}.\\
Unter Windows muss zunächst der Treiber für den \textit{CP2104 USB-to-Serial Chip} installiert werden, auf Linux und Mac entfällt dieser Schritt \cite{fried2017feather}.
Nach der Installation der Arduino IDE muss dort in den Einstellungen unter \textit{Additional Boards Manager URLs} die URL \url{http://arduino.esp8266.com/stable/package_esp8266com_index.json} hinzugefügt werden.  
Nach einem Neustart der IDE kann im \textit{Boards Manager} das Paket für den ESP8266 heruntergeladen werden und anschließend das Board \textit{Adafruit HUZZAH ESP8266} ausgewählt werden. \\
Ist das Board über USB mit dem Computer verbunden, kann nun eigener Code oder eines der Beispiele aus \textit{Examples for Adafruit HUZZAH ESP8266} mit STRG+U auf den ESP geladen werden. 
Dieser Vorgang wird im Folgenden als flashen bezeichnet. \\
Der ESP8266 Arduino Core wird als Open Source Projekt gepflegt und setzt die ESP Open SDK auf einen, für die Arduino IDE üblichen Stil um \cite{arduino2017core}. 
Dabei wird möglichst die Kompatibilität zu Arduino gewahrt, das führt oft dazu, dass bereitgestellte Funktionen der SDK nicht in Arduino umgesetzt wurden.
Sollten die Funktionen dennoch benötigt werden, können die Header-Dateien der SDK direkt importiert werden:

\begin{verbatim}
//Hier wird ein Header des ESP8266 Arduino Core importiert
#include <ESP8266WiFi.h> 

//Hier wird ein Header der ESP Open SDK importiert
extern "C" {#include "user_interface.h"} 
\end{verbatim}

Der ESP8266 Arduino Core wurde in der Version 2.3.0 verwendet.

\subsection{ESP Open SDK}
Statt mit der Arduino Core Umsetzung der ESP Open SDK kann natürlich auch direkt mit ihr programmiert werden \cite{esp2017open}. \\
Dazu muss zunächst das Github Projekt geklont werden: \texttt{git clone --recursive \url{https://github.com/pfalcon/esp-open-sdk}.git} und anschließend mit \texttt{make} kompiliert werden.
Wurde die Kompilierung erfolgreich abgeschlossen, sollte die Pfadvariable (PATH) entsprechend der Meldung des make-Tools erweitert werden. \\
Die in C geschriebenen Programme können nun mit einem modifizierten GCC-Kompiler kompiliert und anschließend mit dem esptool.py zunächst in ein Image umgewandelt und dann geflasht werden. 
Das in \textit{examples} enthaltene \textit{blinky} Beispiel beinhaltet neben dem Beispielcode eine Makefile, in der diese Schritte nachvollzogen werden können, mit \texttt{make flash} wird das Beispiel kompiliert und geflasht. \\
Programme werden in regulärem C unter Zuhilfenahme der in \texttt{/sdk/include} enthaltenen Header-Dateien geschrieben, zu beachten ist nur, dass einige Funktionen der \texttt{stdlib.h} nicht verwendet werden können.
Dies betrifft vor allem direkten Speicherzugriff wie zum Beispiel \texttt{memcpy}, hier muss stattdessen \texttt{os\_memcpy} verwendet werden.
Alle betroffenen Funktionen sind in \texttt{osapi.h} beschrieben. \\
Einige frühe Experimente zeigten, dass Programme, die mit der ESP Open SDK geschrieben wurden auf dem ESP schneller starten, als solche, die mit dem ESP8266 Arduino Core geschrieben wurden.
Diese Andeutung von Ineffizienzen bei der Übersetzung von Arduino Code wurde zum Anlass genommen, für die nachfolgenden Implementierungen nach der Fertigstellung des Prototypen in Arduino ebenfalls eine Implementierung in C hinzuzufügen, um ein optimales Programm zu erhalten. \\
Die ESP Open SDK wurde in der Version 2.0.0 verwendet.

\begin{figure}[h]
  \centering
	\includegraphics[width=0.9\textwidth]{images/activescan.png}
  \caption{Ablaufdiagramm eines aktiven Scan, aus \cite{ieee2012active}.}
  \label{fig:activescan}
\end{figure}







\section{WiFi-LLS Implementierung}
\label{ch:phase1:sec:wifills}
Die mobile Einheit des WiFi-LLS Systems führt alle 5 Sekunden einen Scan aus, kodiert die Ergebnisse in XML und versendet sie an den Ortungsserver \cite{chen2007design}.
Da der Fokus dieser Arbeit auf dem Energieverbrauch liegt, werden für die Referenzimplementierung eines WiFi-LLS-Tags die Kodierung in XML durch eine simple String Kodierung ersetzt und die Ergebnisse werden über UDP an den Ortungsserver übermittelt. 
Damit wird der Overhead einer TCP-Verbindung vermieden.\\
Zunächst muss das Tag dem Netzwerk beitreten (Join), einen Scan ausführen und ein UDP-Paket versenden.
Der Ablauf eines Scans wird in Abbildung \ref{fig:activescan} gezeigt, dieser Vorgang muss für jeden nicht überlappenden Kanal durchgeführt werden.\\
Da die Scan-Funktion des ESP8266 Arduino Core es nicht erlaubt den RSSI zu einem AP auszulesen muss \texttt{user\_interface.h} importiert und die Scan-Funktion der SDK direkt verwendet werden.
Um den Energieverbrauch weiter zu reduzieren, soll der ESP möglichst viel Zeit in Energiesparzuständen verbringen.
Der tiefste Schlafzustand, der dennoch eine Aufrechterhaltung der WLAN-Verbindung erlaubt ist der \texttt{light\_sleep}. 
Er wird vom ESP automatisch aufgerufen, wenn er keine Aufgaben zu erledigen hat.
Er kann aber auch manuell aufgerufen werden, beides wurde getestet.\\
Einige Parameter können gewählt werden. 
Die Intervallzeit bestimmt, wie oft der ESP aktiv ist und damit auch wie viel Energie er verbraucht.
Für Mitarbeiter im Tunnel kann von einer Maximalgeschwindigkeit von $30\ $km/h ausgegangen werden, diese wird durch Schienen- oder Lastkraftfahrzeuge erreicht. 
Die maximale Reichweite des ESP12-S beziehungsweise ESP12-F Moduls ist nicht bekannt und muss noch bestimmt werden, sie wird zwischen 50 und 100 Metern angenommen.
Es wurde daher ein Intervall von 5 Sekunden gewählt, in dieser Zeit bewegt sich ein Mitarbeiter bei 30 km/h ca. 42 Meter.\\
Des Weiteren kann theoretisch die Zahl der gescannten Kanäle gewählt werden. 
Da sich die Einflussbereiche der APs in einem WLAN-Netzwerk üblicherweise überlappen, ist es aber sinnvoll diese über die vier nichtüberlappenden Kanäle zu verteilen. 
Eine Implementierung, die nur einen Kanal scannt tritt deshalb nur außer Konkurenz an.\\
Tabelle \ref{table:llsconsumption} zeigt den gemessenen Energieverbrauch der Implementierungen in Arduino und C, jeweils mit und ohne manuell aufgerufenen \texttt{light\_sleep} und eine Implementierung, die nur einen Channel scannt.
Für die Tests wurde das Adafruit Feather Huzzah verwendet, es wurde mit 5 Volt aus einer USB-Powerbank mit Energie versorgt, der Verbrauch wurde mit einem dazwischen geschalteten TM103 USB-Power-Meter der Marke Muker gemessen. 
Jeder Versuch wurde mindestens eine Stunde durchgeführt.
Wurde in dieser Zeit der Verbrauchswert von 10 mAh nicht überschritten, wurde der Versuch verlängert, da der TM103 den Verbrauch ohne Nachkommastellen anzeigt.\\
Die Werte wurden stationär in einer Mietwohnung in einem fünfstöckigen Wohnhaus und damit nicht unter realen Bedingungen aufgezeichnet.
Unter realen Bedingungen finden durch die Bewegung des Mitarbeiters regelmäßig Reassizationen statt, im Gegenzug liefert ein Scan in einem Tunnel weniger Ergebnisse als in einem Wohnhaus.
Ein Test unter realen Bedingungen ist im Abschnitt \ref{ch:realworld:sec:wifills} zu finden, er beinhaltet jedoch nur noch die Implementierung in C mit manuellem \texttt{light\_sleep} und einem Scan auf allen vier Kanälen.

%TODO Abstand Tabellenüberschrift
\begin{table}[h]
	\centering
	\caption{Energieverbrauch WiFi-LLS-artiger Tags}
	\label{table:llsconsumption}
	\begin{tabular}{p{3cm}|p{2.2cm}|p{1.5cm}|p{2cm}|p{2cm}|p{2cm}}
		SDK & manueller \texttt{light\_sleep} & Anzahl Kanäle & Versuchs-dauer in Stunden & Gesamt-verbrauch in mAh & $\varnothing$ Verbrauch in mA  \\
		\hline
		Arduino Core & Nein & 4 & 1 & 22 & 22 \\
		Arduino Core & Ja & 4 & 1 & 21 & 21 \\
		ESP Open SDK & Nein & 4 & 1 & 19 & 19 \\
		ESP Open SDK & Ja & 4 & 1 & 19 & 19 \\
		\hline
		ESP Open SDK & Ja & 1 & 2 & 13 & 6,5 \\
	\end{tabular}
\end{table}

Die Tests zeigen, dass die Programmierung mit der ESP Open SDK einen Vorteil beim Energieverbrauch hat, dieser liegt bei ca 10\%.
Andererseits fällt auf, dass die Reduzierung der gescannten Channel eine signifikante Senkung des Energieverbrauchs nach sich zieht, die Scan-Funktion ist also der Hauptverbraucher.\\
Um die finale Laufzeit zu bestimmen muss die Kapazität des Akkus bekannt sein.

%TODO So ein Einfügungsblock.
Ein Lithium-Polymer Akku hat eine Nennspannung von 3,7 Volt, seine Kapazität wird in mAh angegeben, der Stromverbrauch wurde aber bei einer Spannung von 5 Volt gemessen. 
Das Feather Huzzah verwendet jedoch einen linearen Spannungsregler.
Für diesen gilt ein Wirkungsgrad $\eta \approx \frac{U_{ein}}{U{aus}}$ mit der ein- beziehungsweise ausgehenden Spannung $U_{ein/aus}$, da die eingehende Stromstärke $I_{ein}$ immer geringfügig über der ausgehenden Stomstärke $I_{aus}$ liegt \cite{streichert2012elektrik}.


Eine Milliamperstunde bei einer Eingangsspannung von 5 Volt kann also mit einer Milliamperstunde bei einer Eingangspannung bei 3,7 Volt gleichgesetzt werden.
Die Laufzeit für einen beispielhaften 1400 mAh Lithium-Polymer Akku beträgt also 1400\ mAh/19\ mA $\approx$ 73,68\ h.
Dies entpricht circa drei Tagen.







\section{Anpassungen für Bereichsortung}
\label{ch:phase1:sec:anpassungbereich}
Bei WiFi-LLS wird der Scan durchgeführt, um den RSSI zu nahen Access Points zu erhalten und dann auf dem Ortungsserver die Position der mobilen Einheit mit einer Trilateration zu berechnen.
Im Tunnel sind oft nur ein bis zwei APs in Reichweite, außerdem wird eine Bereichsortung als ausreichend angesehen. \\
Werden die APs geschickt den Bereichen zugeordnet, reicht das Wissen um einen nahen AP, um das Tag einem Bereich zuzuordnen.
Da dem Tag, die MAC-Adresse seines Netztzugangs bekannt sein muss, kann dies als Ortungsinformation verwendet werden.
Der Wechsel zwischen zwei Access Points wird exemplarisch in Abbildung \ref{fig:reassociation} dargestellt.

\begin{figure}[h!]
  \centering
	\includegraphics[width=\textwidth]{images/reassociation.eps}
  \caption{Vorgang von Assoziation und Reassoziation.}
  \label{fig:reassociation}
\end{figure}

Die MAC-Adresse des Access Points wird nun zusammen mit der eigenen MAC-Adresse als Identifikator als String kodiert und per UDP an den Ortungsserver versendet.\\
Tabelle \ref{table:naiveconsumption} zeigt den gemessen Verbrauch der Implementierungen in Arduino und C, jeweils mit und ohne manuell aufgerufenen \texttt{light\_sleep}.

\begin{table}[h]
	\centering
	\caption{Energieverbrauch der Bereichsortungstags}
	\label{table:naiveconsumption}
	\begin{tabular}{p{3cm}|p{2.2cm}|p{1.7cm}|p{2.5cm}|p{2.5cm}}
		SDK & manueller \texttt{light\_sleep} & Versuchs-dauer in Stunden & Gesamt-verbrauch in mAh & $\varnothing$ Verbrauch in mA \\
		\hline
		Arduino Core & Nein & 1 & 14 & 14 \\
		Arduino Core & Ja & 3 & 212 & 7 \\
		ESP Open SDK & Nein & 2 & 12 & 6 \\
		ESP Open SDK & Ja & 2 & 11 & 5,5 \\
	\end{tabular}
\end{table}

Der Verbrauch liegt wie erwartet unter dem der WiFi-LLS Implementierung, sogar unter der Implementierung, die nur einen Kanal scannt.
Wird der selbe 1400 mAh beziehungsweise 1400 mAh Lithium-Polymer Akku angenommen, liegt die Laufzeit diesmal  bei 1400 mAh/5,5 mA $\approx$ 254,54 h, also bei über zehn Tagen. \\
Als weitere Optimierung könnte ein Tag nur dann senden, wenn eine Reassoziation stattgefunden hat.
Die mangelnde Transportsicherheit von UDP macht dieses Vorgehen jedoch riskant, wenn das Paket verloren geht wird kein Bereichswechsel erkannt.
Um wieder eine begrenzte Transportsicherheit zu erhalten, kann entweder das UDP-Paket mehrfach versendet werden; ohne Reassoziation in einen festen, aber größeren Intervall gesendet werden oder statt eine UDP-Verbindung eine TCP-Verbindung verwendet werden.
Somit ergeben sich neue Testszenarien: Ohne zusätzliche Sicherung, UDP-Paket mehrfach (dreifach) versenden, zusätzliches (30 beziehungsweise 60 Sekunden) Sendeintervall, TCP-Verbindung (offen halten oder nach dem Senden schließen). \\
Da der Verbrauch nun stark von der Anzahl der Reassoziationen abhängt sind im gegebenen, stationären Testszenario keine aussagekräftigen Ergebnisse möglich.
Dennoch sollen die Tests einen Ausgangswert ermitteln, dieser kann als untere Grenze für den Verbrauch einer Implementierung angesehen werden.
Da in den vorherigen Tests die Implementierungen mit der ESP Open SDK verbrauchsärmer waren, wurden alle in Tabelle \ref{table:naiveoptconsumption} gezeigten Implementierungen mit ihr erstellt, der manuelle \texttt{light\_sleep} ist immer aktiv.

\begin{table}[h]
	\centering
	\caption{Energieverbrauch der verbesserten Bereichsortungstags}
	\label{table:naiveoptconsumption}
	\begin{tabular}{p{3.5cm}|p{1.7cm}|p{2.5cm}|p{2.5cm}}
		Transportsicherung & Versuchs-dauer in Stunden & Gesamt-verbrauch in mAh & $\varnothing$ Verbrauch in mA \\
		\hline
		Ohne & 5 & 10 & 2 \\
		Dreifach UDP & 10 & 14 & 1,4 \\
		Zusatzintervall 30s & 13 & 34 & 2,62 \\
		Zusatzintervall 60s & 5 & 8 & 1,6 \\
		TCP (halten) & 10 & 12 & 1,2 \\
		TCP (schließen) & 11 & 12 & 1,09 \\
	\end{tabular}
\end{table}

Der Energieverbrauch sinkt durch das Einsparen von Sendevorgänge deutlich.
Für das Tag, das eine TCP-Verbindung öffnet, dem Ortungsserver seine Assoziation mitteilt und die Verbindung dann wieder schließt, ergibt sich für den angenommenen 1400\ mAh Lithium-Polymer Akku eine Laufzeit von 1400\ mAh/1,07\ mA $\approx$ 1308,41\ h. 
Dies entspricht gut 54 Tagen mit einer Akkuladung, diese werden jedoch in einem Szenario ohne Reassoziation erreicht.
Die tatsächliche Laufzeit muss unter realen Umständen gemessen werden, siehe dazu Abschnitt \ref{ch:realworld:sec:indirekt}.
Da die zusätzlichen Reassoziationen jedoch auch die vorherigen Implementierungen betreffen kann man schließen, dass Tags für die Bereichsortung durch die Ausnutzung von Assoziation und Reassoziation einen erheblich reduzierten Energieverbrauch gegenüber herkömmlichen Tags für die Trilateration aufweisen.






\section{Untersuchung des Energieverbrauchs}
Der Muker TM103 USB-Power-Meter bietet sowohl im Zeit- Als auch im Wertebereich nur eine sehr geringe Auflösung
Der INA219 kann den Verbrauch mit bis zu 333Hz bestimmen und besitzt dabei eine Messgenauigkeit von 99,5\% \cite{texas2015ina}.
Der Stromverbrauch wird über den Spannungsabfall über einen 0,1$\Omega$ Widerstand bestimmt, der verwendete Widerstand besitzt eine Fertigungstoleranz von 1\%.
Die Messgenauigkeit sinkt deshalb auf $99,5\% * 99\% = 98,505\%$. 
Das über $I²C$ auslesbare Register löst den aktuellen Verbrauch in 0,1 Milliamper Schritten auf, Verbräuche darunter können nicht bestimmt werden.\\
Außerdem wird dieses mal durch den JST-Anschluss für den Akku gemessen, dadurch können eventuelle Ineffizienzen des Lithium-Polymer-Ladeschaltkreises aufgezeichnet werden. 
Abbildung \ref{fig:ina219} zeigt den INA219 integriert auf einer Platine, diese wird für die Messungen verwendet.

\begin{figure}[h!]
  \centering
	\includegraphics[width=0.5\textwidth]{images/ina219.jpg}
  \caption{INA219, die mit R100 beschriftete Komponente über dem INA219 ist der Messwiderstand.}
  \label{fig:ina219}
\end{figure}

\subsection{WiFi-LLS}
\label{ch:realworld:sec:wifills}
Abbildung \ref{fig:wifills} zeigt den Lastverlauf nach Anschalten der mobilen Einheit für die Implementierung von WiFi-LLS, wenn ein AP zur Verfügung steht. 

\begin{figure}[h!]
  \centering
	\includegraphics[width=\textwidth]{plots/wifills.png}
  \caption{Lastkurve einer Implementierung von WiFi-LLS.}
  \label{fig:wifills}
\end{figure}

Diese beginnt bei circa einer Sekunde mit dem Scan, nachdem sie diesen beendet hat beginnt sie bei 5 Sekunden mit dem Join Vorgang.\\
Der ESP8266 empfängt während des Join die gesamte Zeit und verbraucht dabei circa 70 Milliamper, nachdem dieser jedoch abgeschlossen ist synchronisiert er sich mit dem AP und lauscht alle 100ms auf den Beacon des AP.
Ist im Beacon eine Aufforderung zum Empfangen für den ESP8266 enhalten empfängt er länger um die Nachricht zu erhalten, ein solches Verhalten ist bei circa 19 Sekunden zu erkennen.\\
Bei 12, 17 und 22 Sekunden werden weitere Scans ausgeführt, diese stehen im Zentrum der Implementierung, da sie implizit die Position bestimmen.
Die rote Kurve in Abbildung \ref{fig:wifillssendv} zeigt diesen Vorgang genauer, ein Scan besteht für jeden gescannten Kanal aus dem Versenden eines Probe Request und anschließenden Empfangen der Probe Responses. 
Abschließend wird ein Paket an den Ortungsserver versendet und der Chip wechselt wieder in einen Zustand, in dem er periodisch die Beacons des AP empfängt.\\

\begin{figure}[h!]
  \centering
	\includegraphics[width=\textwidth]{plots/wifillssendv.png}
  \caption{Lastkurve eines Ortungsvorgangs mit WiFi-LLS.}
  \label{fig:wifillssendv}
\end{figure}

Auffällig ist, dass der Chip circa 8,2 Milliamper verbraucht wenn er nicht empfängt, dagegen gibt das Datenblatt des ESP8266 nur einen Verbrauch von 0,9 Milliamper an.
Das Experiment wurde deshalb mit einem ESP-12F Modul wiederholt, welches nicht auf einem ESP8266 Feather verbaut war, dabei zeigte sich, dass dieses in der selben Situation nur 1,2 Milliamper verbraucht.
Die Lastkurve des einzelnen ESP-12F Modul ist in Abbildung \ref{fig:wifillssendv} grün dargestellt.
Daraus lässt sich schließen, dass die zusätzlichen Komponenten auf dem ESP8266 Feather 7 Milliamper Vebrauch erzeugen, dies ist im Zuge der Laufzeitoptimierung nicht tragbar.\\
Zusätzlich wurde die Implementierung von WiFi-LLS mit nur einem gescannten Kanal geprüft.
Abbildung \ref{fig:wifills1chsend} zeigt den verkürzten Ortungsvorgang.
Da nur ein Kanal gescannt wird, wird nur ein Probe Request versendet.
Nach Empfangen der Antworten wird ein Paket an den Ortungsserver gesendet und der ESP8266 wechselt wieder in den Zustand des periodischen Empfangens.\\

\begin{figure}[h!]
  \centering
	\includegraphics[width=\textwidth]{plots/wifills1chsend.png}
  \caption{Lastkurve des Ortungsvorgangs mit einem gescannten Kanal.}
  \label{fig:wifills1chsend}
\end{figure}

Tabelle \ref{table:wifillsina} listet den durchschnittlichen Verbrauch der Einheiten über eine Stunde.
Die Stromversorgung der Einheiten wurden circa eine Sekunde nach Beginn des Experiments angeschaltet, anschließend treten keine Veränderungen mehr auf.

\begin{table}[h!]
	\centering
	\caption{Energieverbrauch mobiler Einheiten mit WiFi-LLS Implementierung}
	\label{table:wifillsina}
	\begin{tabular}{p{3.5cm}|p{7.5cm}|p{2.5cm}}
		Hardware & Programm & $\varnothing$ Verbrauch in mA \\
		\hline
		ESP8266 Feather & WiFi-LLS alle Kanäle & 42,2 \\
		ESP-12F & WiFi-LLS alle Kanäle & 36,5 \\
		ESP8266 Feather & WiFi-LLS ein Kanal & 18,7 \\
		ESP-12F & WiFi-LLS ein Kanal & 11,4 \\
	\end{tabular}
\end{table}

\subsection{Indirekte Bereichsortung}
\label{ch:realworld:sec:indirekt}
Abbildung \ref{fig:tcphold} zeigt den Lastverlauf nach Anschalten der mobilen Einheit für die Implementierung für Bereichsortung mit aufrecht erhaltener TCP-Verbindung, wenn ein AP zur Verfügung steht. 
Der Beginn des Lastverlaufs ist dem der WiFi-LLS Implementierung ähnlich, es werden ebenfalls Scan und Join durchgeführt.
Da jedoch nur für das Event einer vollständigen (Re-)Assoziation gesendet wird bleibt der ESP8266 anschließend im Zustand des periodischen Empfangens vor Beacons.
Diese wird nur von den Keep Alive Paketen unterbrochen, welche alle 30 Minuten versendet werden.\\

\begin{figure}[h!]
  \centering
	\includegraphics[width=\textwidth]{plots/tcphold.png}
  \caption{Lastkurve einer Implementierung indirekter Bereichsortung, welche eine TCP Verbindung offen hält.}
  \label{fig:tcphold}
\end{figure}

Für die Implementierung mit anschließendem Abbau der TCP-Verbindung kommen zusätzliche Pakete direkt nach dem versenden der Assoziationsinformation an den Ortungsserver hinzu, dafür entfallen die Keep Alive Pakete.
Abbildung \ref{fig:tcpdisco} zeigt dieses Verhalten.\\

\begin{figure}[h!]
  \centering
	\includegraphics[width=\textwidth]{plots/tcpdisco.png}
  \caption{Lastkurve einer Implementierung indirekter Bereichsortung, welche eine TCP Verbindung nach dem Senden abbaut.}
  \label{fig:tcpdisco}
\end{figure}

Auch diese Implementierungen wurden sowohl mit einem ESP8266 Feather, als auch m,it einem einzelnen ESP-12F Modul getestet, die Ergebnisse sind in Tabelle \ref{table:associatonina} zu finden.

\begin{table}[h!]
	\centering
	\caption{Energieverbrauch mobiler Einheiten mit Bereichsortung}
	\label{table:associatonina}
	\begin{tabular}{p{3.5cm}|p{7.5cm}|p{2.5cm}}
		Hardware & Programm & $\varnothing$ Verbrauch in mA \\
		\hline
		ESP8266 Feather & Bereichsortung TCP Verbindung halten & 15,5 \\
		ESP-12F & Bereichsortung TCP Verbindung halten & 8,8 \\
		ESP8266 Feather & Bereichsortung TCP Verb. schließen & 15,4 \\
		ESP-12F & Bereichsortung TCP Verb. schließen & 8,8 \\
	\end{tabular}
\end{table}





\section{Reichweite von WLAN}
Für die Tests wurde ein LN-862 Access Point von der Firma Lancom zur Verfügung gestellt.
Dieser wurde am hinteren Ende einer Tunnelbohrmaschine montiert.\\
Die Tunnelbohrmaschine befindet sich in der Tunnelbaustelle Rastatt. 
Der Durchmesser des Bahntunnels beträgt 9 Meter, das Ende der Tunnelbohrmaschine befand zum Zeitpunkt der Messungen circa 2 Kilometer weit im Tunnel.\\
Der AP konnte aufgrund des geringen Platzangebots und den wenigen zur Verfügung stehenden Steckdosen nicht frei platziert werden.
Er wurde deshalb unter der ersten stählernen Treppe platziert, diese beeinträchtigt natürlich das Signal.
Da es aber üblich ist IT-Gerätschaften, wie die derzeit verwendeten Bluetooth-Basisstationen, in Metallboxen zu verstauen um sie vor äußeren Einflüssen zu schützen, ist eine gewisse Abschirmung durchaus realitätsnah.
Die Platzierung des AP ist auf Abbildung \ref{fig:tunnelmark} eingezeichnet.\\
Abbildung \ref{fig:applacement} zeigt den LN-862 hinter der Treppe.

\begin{figure}[h]
  \centering
	\includegraphics[width=\textwidth]{images/tunnelmark.png}
  \caption{Ende der Tunnelbohrmaschine, Pfeil markiert Platzierung des Access Point hinter der Treppe.}
  \label{fig:tunnelmark}
\end{figure}

\begin{figure}[h]
  \centering
	\includegraphics[width=\textwidth]{images/applacement.jpg}
  \caption{LN-862 im Tunnel, darauf liegt der Pi Zero W.}
  \label{fig:applacement}
\end{figure}

\subsection{Methodik}
Die Reichweite in zwei Richtungen geprüft.
Zum einen in Richtung des bereits fertig gebohrten Tunnels, hier blockiert nur wenig Stahl das Signal. 
Lediglich die Treppe, unter der der AP montiert wurde, stellt ein Hindernis dar.
Zum anderen wurde die Reichweite in Richtung des Vortriebs geprüft.
Dabei stellen eine stählerne Zwischendecke und große Container Hindernisse dar.\\
Außerdem wird die Abschrimung durch ein Gehäuse getestet.
Dazu wurde eine stabile Plastikbox verwendet, leider konnte diese für den Versuch mit der Bleutooth-basierten mobilen Einheit nicht vollends geschlossen werden.\\
Für die Messung wurde der Körper zwischen mobiler Einheit und Basisstation gebracht und eine mobile Einheit wurde dann als "außer Reichweite" angesehen, wenn versendete Pakete der mobilen Einheit nicht mehr bei der Basisstation ankamen.
In jedem Fall war es möglich durch das Entfernen des körperlichen Hindernisses wieder eine Verbindung herzustellen.\\
Zur Bestimmung der Distanz wurden die Tübbinge verwendet, dies sind Schalungselemente im Tunnel.
Im Tunnel Raststatt sind diese fortlaufend nummeriert und genau zwei Meter breit, die Messungen sind deshalb ebenfalls in zwei Meter Schritten angegeben.

\subsection{Ergebnisse}
Tabelle \ref{table:rangewifi} zeigt die Ergebnisse für die zwei verwendeten ESP8266 Module.
Es wurde jeweils mit und ohne Gehäuse gemessen und in jede der beiden beschriebenen Richtungen.
Wenige Hindernisse bezeichnet dabei die Richtung des bereits fertig gebohrten Tunnels, viele Hindernisse die Richtung des Vortriebs.

\begin{table}[h]
	\centering
	\caption{Sendereichweite WLAN-basierter mobiler Einheiten}
	\label{table:rangewifi}
	\begin{tabular}{p{3.5cm}|p{3cm}|p{3.5cm}|p{3cm}}
		Verwendetes Modul & Aufbau & Strecke & Maximale Sendereichweite \\
		\hline
		ESP-12E & Offen & Wenige Hindernisse & 84m \\
		ESP-12E & In Gehäuse & Wenige Hindernisse & 74m \\
		ESP-12E & Offen & Viele Hindernisse & 26m \\
		ESP-12E & In Gehäuse & Viele Hindernisse & 30m \\
		\hline
		ESP-12F & Offen & Wenige Hindernisse & 88m \\
		ESP-12F & In Gehäuse & Wenige Hindernisse & 88m \\
		ESP-12F & Offen & Viele Hindernisse & 32m \\
		ESP-12F & In Gehäuse & Viele Hindernisse & 32m \\
	\end{tabular}
\end{table}


\subsection{Bewertung}
\label{ch:Reichweite:sec:bewertung}
Das ESP-12F Modul hatte in jedem der vier Testszenarien eine höhere Reichweite als das ESP-12E, es ist daher im weiteren Verlauf zu bevorzugen.\\
Die bisher angenommenen 50 Meter Reichweite sind für dieses Modul deutlich zu vorsichtig geschätzt. 
Um die gemessenen 88 Meter bei 30 km/h zu durchqueren benötigte ein Mitarbeiter circa 10,5 Sekunden, bei einem Sendeintervall von zehn Sekunden finden demnach zwei Sendevorgänge beim durchqueren des Einflussbereichs eines APs statt.
Da eine zuverlässige Erkennung von Bereichswechseln gefordert wurde, sollte das Sendeintervall konservativer auf acht Sekunden gesetzt werden.\\
Für die Teststrecke mit vielen Hindernissen wurden geringere Reichweiten gemessen, eine solche Teststecke findet sich aber nur auf der Tunnelbohrmaschine, welche nur zu Fuß begangen werden kann. 
Geht man von einer maximalen Bewegungsgeschwindigkeit von zehn km/h für eine laufende Person aus durquerte diese in acht Sekunden 22 Meter, also deutlich weniger als die gemessenen 32 Meter.\\

